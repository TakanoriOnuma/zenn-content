---
title: "ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã§æ—¥ä»˜ã‚’é¸æŠã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œã£ã¦ã¿ãŸ"
emoji: "ğŸˆ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["mui", "react"]
published: true
---

## å§‹ã‚ã«

æ—¥ä»˜ã®é¸æŠã®UIã§ã‚ˆãã‚ã‚‹ã‚‚ã®ã¯ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã ã¨æ€ã„ã¾ã™ãŒã€ã‚¹ãƒãƒ›ã‚¢ãƒ—ãƒªã§ã¯ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã¨å‘¼ã°ã‚Œã‚‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦æ—¥ä»˜ã‚’é¸ã¶ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚Webã§ã‚‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒãªã„ã‹èª¿ã¹ãŸã¨ã“ã‚ã€ã„ãã¤ã‹å‡ºã¦ãã¾ã—ãŸã€‚

https://www.npmjs.com/package/react-mobile-picker
https://www.plus-one.tech/vue-drumroll-datetime-picker/

ã—ã‹ã— `react-mobile-picker` ã¯wheelã«ã‚ˆã‚‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®ç§»å‹•é‡ãŒå¤šã™ãã‚‹å•é¡ŒãŒã‚ã‚Šã€ `vue-drumroll-date-time-picker` ã¯æ“ä½œæ„Ÿã¯è¿‘ã„ã‚‚ã®ã®æ–‡å­—ã‚’ã‚‚ã†ã¡ã‚‡ã£ã¨å¤§ããã—ãŸã„ãªã©ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´ã—ãŸã„ã®ã¨ã€ãã‚‚ãã‚‚Vue.jsã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã®ã§Reactã§ã¯ä½¿ãˆãªã„å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸã€‚
ãã“ã§ `vue-drumroll-date-time-picker` ã®æŒ™å‹•ã‚’å‚è€ƒã«ã—ã¤ã¤ã€MUIã‚’ä½¿ã£ã¦ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã‚’è‡ªä½œã—ã¦ã¿ãŸã®ã§å‚™å¿˜éŒ²ã¨ã—ã¦ã¾ã¨ã‚ã¾ã—ãŸã€‚

### ä½œã£ãŸã‚‚ã®

ä»Šå›ä½œã£ãŸã‚‚ã®ã¯ä»¥ä¸‹ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œã£ã¦ã€ãã‚Œã‚’çµ„ã¿åˆã‚ã›ã¦æœ€çµ‚çš„ã«æ—¥ä»˜é¸æŠã®ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã‚’ä½œã‚Šã¾ã—ãŸã€‚

- `ScrollPicker`: ä¸€åˆ—åˆ†ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§é¸æŠã§ãã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- `DateScrollPicker`: å¹´æœˆæ—¥ãã‚Œãã‚Œã«å¯¾ã—ã¦`ScrollPicker`ã‚’å‘¼ã‚“ã§æ—¥ä»˜ã‚’é¸æŠã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- `InputDateByScrollPicker`: ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¾ãŸã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§`DateScrollPicker`ã‚’å‘¼ã³ã€é¸æŠã—ãŸçµæœã‚’ç¢ºå®šã—ã¦æ—¥ä»˜ã‚’å…¥åŠ›ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

![](/images/date-scroll-picker/demo-all-picker.gif)

å‹•ä½œç¢ºèªãƒšãƒ¼ã‚¸ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

https://takanorionuma.github.io/trial-stackblitz-scroll-picker/

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®StackBlitzã®URLã‹ãƒªãƒã‚¸ãƒˆãƒªã®æ–¹ã‚’ã”å‚ç…§ãã ã•ã„ã€‚
https://stackblitz.com/~/github.com/TakanoriOnuma/trial-stackblitz-scroll-picker?file=src/App.tsx
https://github.com/TakanoriOnuma/trial-stackblitz-scroll-picker

## ScrollPickerã®ä½œæˆ

### ScrollPickerã®åœŸå°ã‚’ä½œæˆ

ã¾ãšã¯ScrollPickerã‚’ä½œæˆã—ã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ã«ã¨ã‚Šã‚ãˆãšé …ç›®ã‚’ä¸¦ã¹ã¦ã€ä¸Šä¸‹ã«ç™½ã„å½±ã‚’ä¹—ã›ã¦è¦‹ãŸç›®ã‚’æ•´ãˆã¾ã™ã€‚

```tsx:ScrollPickerã®åœŸå°ã‚’ä½œæˆ
import { useRef, useEffect, CSSProperties } from "react";
import { Box, MenuList, MenuItem, useForkRef } from "@mui/material";

/** 1ã¤ã®é …ç›®ã®é«˜ã• */
const SCROLL_ITEM_HEIGHT = 40

/** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦é¸æŠã™ã‚‹é …ç›® */
export type ScrollItem<V> = {
  value: V;
  label: string;
  disabled?: boolean;
};

/**
 * æ“¬ä¼¼è¦ç´ ã«è¨­å®šã™ã‚‹å½±ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹
 * @param position - é…ç½®ã•ã›ã‚‹ä½ç½®
 */
const createPseudoShadowStyle = (
  position: "top" | "bottom"
): CSSProperties => ({
  content: '""',
  position: "absolute",
  zIndex: 1,
  top: position === "top" ? 0 : undefined,
  bottom: position === "bottom" ? 0 : undefined,
  left: 0,
  width: "100%",
  height: "40%",
  background: `linear-gradient(to ${position}, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1))`,
  pointerEvents: "none",
});

export type ScrollPickerProps<V> = {
  /** é¸æŠä¸­ã®å€¤ */
  value: V;
  /** é¸æŠãƒªã‚¹ãƒˆ */
  items: ScrollItem<V>[];
  /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ©ãƒ¼ã®é«˜ã• */
  height?: number;
  /**
   * å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚
   * @param newValue - æ–°ã—ã„å€¤
   */
  onChangeValue: (newValue: V) => void;
};

export const ScrollPicker = function <V>({
  value,
  items,
  height = 5 * SCROLL_ITEM_HEIGHT,
  onChangeValue,
}: ScrollPickerProps<V>) {
  /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®å§‹ç«¯ãƒ»çµ‚ç«¯ãŒãƒ”ãƒƒã‚¿ãƒªçœŸã‚“ä¸­ã§åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´ã™ã‚‹ä½™ç™½ã®é«˜ã• */
  const paddingHeight = (height - SCROLL_ITEM_HEIGHT) / 2;

  return (
    <Box
      sx={{
        position: "relative",
        height,
        "&::before": createPseudoShadowStyle("top"),
        "&::after": createPseudoShadowStyle("bottom"),
      }}
    >
      <MenuList
        sx={{
          height: "100%",
          overflowY: "scroll",
          "&::-webkit-scrollbar": {
            display: "none",
          },
        }}
        disablePadding
      >
        <MenuItem
          key={`pad-top`}
          sx={{
            height: paddingHeight,
            minHeight: "auto",
          }}
          disabled
        />
        {items.map((item) => (
          <MenuItem
            key={String(item.value)}
            style={{
              height: SCROLL_ITEM_HEIGHT,
              minHeight: "auto",
              textAlign: "center",
            }}
            selected={item.value === value}
            disabled={item.disabled}
            onClick={() => {
              onChangeValue(item.value)
            }}
          >
            <ListItemText
              sx={{
                "& > .MuiListItemText-primary": {
                  fontWeight: item.value === value ? "bold" : undefined,
                },
              }}
              primary={item.label}
            />
          </MenuItem>
        ))}
        <MenuItem
          key={`pad-bottom`}
          sx={{
            height: paddingHeight,
            minHeight: "auto",
          }}
          disabled
        />
      </MenuList>
    </Box>
  );
};
```

ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‘¼ã¶ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã«ãªã‚Šã¾ã™ã€‚

![](/images/date-scroll-picker/design-scroll-picker.png)

### ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†å¾Œã«ä¸­å¿ƒã«ã‚ã‚‹é …ç›®ã‚’é¸æŠã™ã‚‹(wheelã‚¤ãƒ™ãƒ³ãƒˆ)

ç¶šã„ã¦ã¯ScrollPickerã®é†é†å‘³ã§ã‚ã‚‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†å¾Œã«ä¸­å¿ƒã«ã‚ã‚‹é …ç›®ã‚’é¸æŠã™ã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã™ã€‚æœ€åˆã¯`scroll`ã‚¤ãƒ™ãƒ³ãƒˆã§å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã¦ã¾ã—ãŸãŒã€ã‚¿ãƒƒãƒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®ç§»å‹•é‡ãŒAndroidã¨iOSã§å¤§ããç•°ãªã£ã¦ã„ã¦æ“ä½œæ„Ÿã«é•ã„ãŒã‚ã£ãŸã®ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒç™ºç”Ÿã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®æ–¹ã‚’ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã—ã¦è‡ªå‰ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚
ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†ã‚’é€šçŸ¥ã™ã‚‹hooksãŒã‚ã‚‹ã¨ãƒ­ã‚¸ãƒƒã‚¯ã®è¦‹é€šã—ãŒè‰¯ããªã‚‹ã®ã§ã¾ãšã¯ãã‚Œç”¨ã®hooksã‚’ä½œã‚Šã¾ã™ã€‚ãã®ä¸­ã§ã‚‚å®Ÿè£…ãŒç°¡å˜ãªãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã§ã‚ã‚‹`wheel`ã‚¤ãƒ™ãƒ³ãƒˆã®æ–¹ã‚’å…ˆã«å®Ÿè£…ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã—ãŸã€‚

```tsx:useHandleScroll.ts
import { useMemo } from "react";

/**
 * ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’JSå´ã§åˆ¶å¾¡ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
 */
export const useHandleScroll = ({
  onFinishScroll,
}: {
  /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒçµ‚äº†ã—ãŸæ™‚ */
  onFinishScroll: () => void;
}) => {
  const ref = useMemo(() => {
    let cachedElement: HTMLElement | null = null;
    let timerId: number | undefined;
    const handleWheel = (event: WheelEvent) => {
      event.stopPropagation();
      if (cachedElement == null) {
        return;
      }
      cachedElement.scrollTop += event.deltaY;

      clearTimeout(timerId);
      timerId = window.setTimeout(() => {
        onFinishScroll();
      }, 100);
    };

    return (element: HTMLElement | null) => {
      if (element == null) {
        if (cachedElement != null) {
          cachedElement.removeEventListener("wheel", handleWheel);
        }
        clearTimeout(timerId);
        cachedElement = null;
        return;
      }

      cachedElement = element;
      cachedElement.addEventListener("wheel", handleWheel);
    };
  }, [onFinishScroll]);

  return {
    ref,
  };
};
```

ã“ã‚Œã‚’å…ˆã»ã©ã®`ScrollPicker.tsx`ã§ä½¿ç”¨ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```diff tsx:useHandleScrollã‚’ScrollPickerã§ä½¿ç”¨ã™ã‚‹
-import { Box, MenuList, MenuItem } from "@mui/material";
+import { Box, MenuList, MenuItem, useForkRef } from "@mui/material";
 import { useHandleScroll } from "./hooks/useHandleScroll";

 // ä¸€éƒ¨çœç•¥

 export const ScrollPicker = function <V>({
   value,
   items,
   height = 5 * SCROLL_ITEM_HEIGHT,
   onChangeValue,
 }: ScrollPickerProps<V>) {
+  const elMenuListRef = useRef<HTMLElement | null>(null);
   /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®å§‹ç«¯ãƒ»çµ‚ç«¯ãŒãƒ”ãƒƒã‚¿ãƒªçœŸã‚“ä¸­ã§åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´ã™ã‚‹ä½™ç™½ã®é«˜ã• */
   const paddingHeight = (height - SCROLL_ITEM_HEIGHT) / 2;

+  const { ref: refScroller } = useHandleScroll({
+    onFinishScroll: () => {
+      const elMenuList = elMenuListRef.current;
+      if (elMenuList == null) {
+        return;
+      }
+      const index = Math.round(elMenuList.scrollTop / SCROLL_ITEM_HEIGHT);
+      const itemValue = items[index]?.value;
+      if (itemValue === undefined) {
+        return;
+      }
+      onChangeValue(itemValue);
+    },
+  });
+  const handleRef = useForkRef(elMenuListRef, refScroller);

   return (
     <Box
       sx={{
         position: "relative",
         height,
         "&::before": createPseudoShadowStyle("top"),
         "&::after": createPseudoShadowStyle("bottom"),
       }}
     >
       <MenuList
+        ref={handleRef}
         sx={{
           height: "100%",
           overflowY: "scroll",
           "&::-webkit-scrollbar": {
             display: "none",
           },
         }}
         disablePadding
       >
         {/* ä¸­èº«ã¯åŒã˜ãŸã‚çœç•¥ */}
       </MenuList>
     </Box>
   );
 };
```

ã“ã‚Œã§ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§å€¤ãŒé¸æŠã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

![](/images/date-scroll-picker/selected-after-wheel.gif)

### é¸æŠã•ã‚ŒãŸå€¤ãŒä¸­å¿ƒã«é…ç½®ã•ã‚Œã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã™ã‚‹

ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§å€¤ã¯é¸æŠã•ã‚Œã¾ã—ãŸãŒã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã¯ä¸­å¿ƒã«ãƒ”ãƒƒã‚¿ãƒªä½ç½®ã¥ã„ã¦ã„ãŸæ–¹ãŒè‰¯ã„ã¨æ€ã†ã®ã§ã€å€¤ãŒå¤‰ã‚ã£ãŸæ™‚ã«useEffectã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã—ã¾ã™ã€‚ã¾ãŸå€¤ãŒå¤‰æ›´ã•ã‚Œãªã‹ã£ãŸå ´åˆã€ä¸­é€”åŠç«¯ãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã®ã¾ã¾ã ã¨é•å’Œæ„Ÿãªã®ã§å…ƒã®å ´æ‰€ã«æˆ»ã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¾ã™ã€‚

```diff tsx:é¸æŠã•ã‚ŒãŸå€¤ãŒä¸­å¿ƒã«é…ç½®ã•ã‚Œã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã™ã‚‹
 // ä¸€éƒ¨çœç•¥

+/**
+ * å¯¾å‡¦ã®å€¤ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹
+ * @param elMenuList - ulè¦ç´ 
+ * @param items - é …ç›®ãƒªã‚¹ãƒˆ
+ * @param targetValue - ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å…ˆã®å€¤
+ * @param options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
+ */
+export const scrollToItemValue = function <V>(
+  elMenuList: HTMLElement,
+  items: ScrollItem<V>[],
+  targetValue: V,
+  {
+    disableAnimation,
+  }: {
+    /** ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã›ãšå³æ™‚ç§»å‹•ã•ã›ã‚‹ã‹ */
+    disableAnimation?: boolean;
+  } = {}
+) {
+  const targetIndex = items.findIndex((item) => item.value === targetValue);
+  if (targetIndex < 0) {
+    return;
+  }
+
+  const scrollTop = targetIndex * SCROLL_ITEM_HEIGHT;
+  if (disableAnimation) {
+    elMenuList.scrollTop = scrollTop;
+    return;
+  }
+  elMenuList.scrollTo({
+    top: scrollTop,
+    behavior: "smooth",
+  });
+};

 export const ScrollPicker = function <V>({
   value,
   items,
   height = 5 * SCROLL_ITEM_HEIGHT,
   onChangeValue,
 }: ScrollPickerProps<V>) {
+  /** åˆå›ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‹ï¼ˆåˆå›ã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ãªãç›´æ¥scrollTopã‚’å¤‰æ›´ã™ã‚‹ï¼‰ */
+  const isFirstScrollRef = useRef<boolean>(true);
   const elMenuListRef = useRef<HTMLElement | null>(null);
   /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®å§‹ç«¯ãƒ»çµ‚ç«¯ãŒãƒ”ãƒƒã‚¿ãƒªçœŸã‚“ä¸­ã§åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´ã™ã‚‹ä½™ç™½ã®é«˜ã• */
   const paddingHeight = (height - SCROLL_ITEM_HEIGHT) / 2;

+  useEffect(() => {
+    const elMenuList = elMenuListRef.current;
+    if (elMenuList == null) {
+      return;
+    }
+
+    const isFirstScroll = isFirstScrollRef.current;
+    isFirstScrollRef.current = false;
+
+    scrollToItemValue(elMenuList, items, value, {
+      disableAnimation: isFirstScroll,
+    });
+  }, [items, value]);

   const { ref: refScroller } = useHandleScroll({
     onFinishScroll: () => {
       const elMenuList = elMenuListRef.current;
       if (elMenuList == null) {
         return;
       }
       const index = Math.round(elMenuList.scrollTop / SCROLL_ITEM_HEIGHT);
       const itemValue = items[index]?.value;
       if (itemValue === undefined) {
         return;
       }
+      // åŒã˜å€¤ã‚’ç®—å‡ºã—ãŸå ´åˆã¯åŒã˜å ´æ‰€ã«æˆ»ã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦çµ‚äº†ã™ã‚‹
+      if (itemValue === value) {
+        scrollToItemValue(elMenuList, items, itemValue);
+        return;
+      }
       onChangeValue(itemValue);
     },
   });
   const handleRef = useForkRef(elMenuListRef, refScroller);

   return (
     // renderå†…å®¹ã¯ä¸€ç·’ãªã®ã§çœç•¥
   );
 };
```

ã“ã‚Œã§é¸æŠã—ãŸå€¤ãŒä¸­å¿ƒã«æ¥ã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã—ã¦ãã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

![](/images/date-scroll-picker/followed-selected-value.gif)

### disabledã®é …ç›®ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã«å½“ãŸã£ãŸæ™‚ã¯å‰å¾Œã§æœ€ã‚‚è¿‘ã„é …ç›®ã‚’é¸ã¶ã‚ˆã†ã«ã™ã‚‹

disabledã®é …ç›®ãŒã‚ã‚‹å ´åˆã¯ã“ã®ä½ç½®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒæ­¢ã¾ã£ã¦ã‚‚é¸æŠã•ã‚Œã¦ã—ã¾ã£ã¦ã¯å›°ã‚‹ãŸã‚ã€å‰å¾Œã§æœ€ã‚‚è¿‘ã„é¸æŠå¯èƒ½ãªé …ç›®ã‚’é¸ã¶ã‚ˆã†ã«èª¿æ•´ã—ã¾ã™ã€‚`findSelectableScrollItemValue`ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒã‹ãªã‚Šã”ã¡ã‚ƒã¤ã„ã¦ã„ã¾ã™ãŒã€ã–ã£ãã‚Šå›³ã«ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªå ´æ‰€ã«å¯¾ã—ã¦å¤‰æ•°ã‚’ã¤ã‘ã¦ãŠã‚Šã€ã“ã“ã‹ã‚‰æœ€ã‚‚è¿‘ã„é¸æŠå¯èƒ½ãªé …ç›®ã‚’æ¢ã—ã¦ã„ã¾ã™ã€‚

![](/images/date-scroll-picker/find-closest-selectable-item.png)

```diff tsx:disabledã®é …ç›®ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã«å½“ãŸã£ãŸæ™‚ã¯å‰å¾Œã§æœ€ã‚‚è¿‘ã„é …ç›®ã‚’é¸ã¶ã‚ˆã†ã«ã™ã‚‹
 // ä¸€éƒ¨çœç•¥

+/**
+ * ulè¦ç´ ã®scrollTopã‹ã‚‰é¸æŠå¯èƒ½ãªé …ç›®ã®å€¤ã‚’å–å¾—ã™ã‚‹
+ * @param elMenuList - ulè¦ç´ 
+ * @param currentValue - ç¾åœ¨ã®å€¤
+ * @param items - é …ç›®ãƒªã‚¹ãƒˆ
+ */
+export const findSelectableScrollItemValue = function <V>(
+  elMenuList: HTMLElement,
+  currentValue: V,
+  items: ScrollItem<V>[]
+): V | undefined {
+  const index = Math.round(elMenuList.scrollTop / SCROLL_ITEM_HEIGHT);
+  const item = items[index];
+  if (item == null) {
+    return undefined;
+  }
+  if (!item.disabled) {
+    return item.value;
+  }
+
+  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã«ã‚ã‚‹é …ç›®ãŒdisabledã®å ´åˆã€æœ€ã‚‚è¿‘ã„æœ‰åŠ¹ãªé …ç›®ã‚’æ¢ã™
+  const currentIndex = items.findIndex((item) => item.value === currentValue);
+  // é¸æŠä¸­ã®é …ç›®ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
+  if (currentIndex === -1) {
+    return undefined;
+  }
+  // åŒã˜å ´æ‰€ã‚’æŒ‡ã—ãŸå ´åˆã¯ç¾åœ¨ã®å€¤ã‚’è¿”ã™
+  if (currentIndex === index) {
+    return currentValue;
+  }
+
+  const possiblyTopItems = items.slice(0, index).reverse();
+  const possiblyTopItemIndex = possiblyTopItems.findIndex(
+    (item) => !item.disabled
+  );
+  const possiblyBottomItems = items.slice(index + 1);
+  const possiblyBottomItemIndex = possiblyBottomItems.findIndex(
+    (item) => !item.disabled
+  );
+
+  // ã©ã¡ã‚‰ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
+  if (possiblyTopItemIndex === -1 && possiblyBottomItemIndex === -1) {
+    return undefined;
+  }
+  // ã©ã¡ã‚‰ã‹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯è¦‹ã¤ã‹ã£ãŸæ–¹ã‚’è¿”ã™
+  if (possiblyTopItemIndex === -1) {
+    return possiblyBottomItems[possiblyBottomItemIndex]?.value;
+  }
+  if (possiblyBottomItemIndex === -1) {
+    return possiblyTopItems[possiblyTopItemIndex]?.value;
+  }
+  // ã©ã¡ã‚‰ã‚‚è¦‹ã¤ã‹ã£ãŸå ´åˆã¯è¿‘ã„æ–¹ã‚’è¿”ã™
+  if (possiblyTopItemIndex < possiblyBottomItemIndex) {
+    return possiblyTopItems[possiblyTopItemIndex]?.value;
+  }
+  if (possiblyTopItemIndex > possiblyBottomItemIndex) {
+    return possiblyBottomItems[possiblyBottomItemIndex]?.value;
+  }
+  // ã©ã¡ã‚‰ã‚‚åŒã˜è·é›¢ã®å ´åˆã¯ã€é¸æŠä¸­ã®é …ç›®ã‹ã‚‰è¿‘ã„æ–¹ã‚’è¿”ã™
+  if (currentIndex < index) {
+    return possiblyTopItems[possiblyTopItemIndex]?.value;
+  }
+  if (currentIndex > index) {
+    return possiblyBottomItems[possiblyBottomItemIndex]?.value;
+  }
+  // ãã‚Œä»¥å¤–ã®ã‚±ãƒ¼ã‚¹ã¯ã‚ã‚Šå¾—ãªã„ãŒã€å¿µã®ãŸã‚ç¾åœ¨ã®å€¤ã‚’è¿”ã™
+  return currentValue;
+};

 export const ScrollPicker = function <V>({
   value,
   items,
   height = 5 * SCROLL_ITEM_HEIGHT,
   onChangeValue,
 }: ScrollPickerProps<V>) {
   // ä¸€éƒ¨çœç•¥

   const { ref: refScroller } = useHandleScroll({
     onFinishScroll: () => {
       const elMenuList = elMenuListRef.current;
       if (elMenuList == null) {
         return;
       }
-      const index = Math.round(elMenuList.scrollTop / SCROLL_ITEM_HEIGHT);
-      const itemValue = items[index]?.value;
+      const itemValue = findSelectableScrollItemValue(elMenuList, value, items);
       if (itemValue === undefined) {
         return;
       }
       // åŒã˜å€¤ã‚’ç®—å‡ºã—ãŸå ´åˆã¯åŒã˜å ´æ‰€ã«æˆ»ã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦çµ‚äº†ã™ã‚‹
       if (itemValue === value) {
         scrollToItemValue(elMenuList, items, itemValue);
         return;
       }
       onChangeValue(itemValue);
     },
   });
   const handleRef = useForkRef(elMenuListRef, refScroller);

   return (
     // renderå†…å®¹ã¯ä¸€ç·’ãªã®ã§çœç•¥
   );
 };
```

ã“ã‚Œã§ä»¥ä¸‹ã®ã‚ˆã†ã«disabledãªé …ç›®ãŒã‚ã‚‹å ´åˆã«è¿‘ã„é …ç›®ãŒé¸æŠã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

![](/images/date-scroll-picker/demo-scroll-with-disabled-item.gif)

### ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†å¾Œã«ä¸­å¿ƒã«ã‚ã‚‹é …ç›®ã‚’é¸æŠã™ã‚‹(touch/mouseã‚¤ãƒ™ãƒ³ãƒˆ)

ä»¥ä¸Šã§wheelæ“ä½œã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹éƒ¨åˆ†ã¯çµ‚ã‚ã‚Šã¾ã—ãŸã€‚ã“ã“ã‹ã‚‰ã¯ã‚¿ãƒƒãƒã‚‚å¯¾å¿œã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚å®Ÿè£…è‡ªä½“ã¯mouseã®ãƒ‰ãƒ©ãƒƒã‚°ã‚‚åŒã˜ã‚ˆã†ã«æ›¸ã‘ã‚‹ã®ã§ã¤ã„ã§ã«å®Ÿè£…ã—ã¾ã™ã€‚
ã‚¿ãƒƒãƒæ“ä½œã«ã‚ˆã‚‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒiOSã¨Androidã§ã‚¹ãƒ”ãƒ¼ãƒ‰ãŒç•°ãªã£ã¦ã„ã¦ä¸­ã€…æ€ã£ãŸå ´æ‰€ã«æ­¢ã‚ã‚‹ã“ã¨ãŒã§ããªã‹ã£ãŸã®ã§è‡ªå‰ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚å®Ÿè£…è‡ªä½“ã¯å˜ç´”ã§ã‚¿ãƒƒãƒã®é–‹å§‹ä½ç½®ã‹ã‚‰å·®åˆ†ã‚’è¦‹ã¦ã€ãã®å¤‰åŒ–é‡ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã—ã¾ã™ã€‚

```diff tsx:ã‚¹ãƒ¯ã‚¤ãƒ—ã‚„ãƒ‰ãƒ©ãƒƒã‚°ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
 /**
  * ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’JSå´ã§åˆ¶å¾¡ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
  */
 export const useHandleScroll = ({
   onFinishScroll,
 }: {
   /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒçµ‚äº†ã—ãŸæ™‚ */
   onFinishScroll: () => void;
 }) => {
   const ref = useMemo(() => {
     let cachedElement: HTMLElement | null = null;
     // wheelã®å®šç¾©ã¯çœç•¥

+    /** ã‚¿ãƒƒãƒé–‹å§‹åº§æ¨™ */
+    let startPosY: number | null = null;
+    /** ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½® */
+    let startScrollTop: number | null = null;
+    const handleTouchStart = (event: TouchEvent | MouseEvent) => {
+      event.preventDefault();
+      startPosY =
+        "touches" in event ? event.touches[0]?.clientY ?? null : event.clientY;
+      startScrollTop = cachedElement?.scrollTop ?? null;
+    };
+    const handleTouchMove = (event: TouchEvent | MouseEvent) => {
+      if (
+        startPosY == null ||
+        startScrollTop == null ||
+        cachedElement == null
+      ) {
+        return;
+      }
+      const posY =
+        "touches" in event ? event.touches[0]?.clientY : event.clientY;
+      if (posY == null) {
+        return;
+      }
+      const diff = startPosY - posY;
+      cachedElement.scrollTop = startScrollTop + diff;
+    };
+    const handleTouchEnd = (event: TouchEvent | MouseEvent) => {
+      event.preventDefault();
+
+      startPosY = null;
+      startScrollTop = null;
+      onFinishScroll();
+    };
     return (element: HTMLElement | null) => {
       if (element == null) {
         if (cachedElement != null) {
           cachedElement.removeEventListener("wheel", handleWheel);
+          cachedElement.removeEventListener("touchstart", handleTouchStart);
+          cachedElement.removeEventListener("touchmove", handleTouchMove);
+          cachedElement.removeEventListener("touchend", handleTouchEnd);
+          cachedElement.removeEventListener("mousedown", handleTouchStart);
+          cachedElement.removeEventListener("mousemove", handleTouchMove);
+          cachedElement.removeEventListener("mouseup", handleTouchEnd);
+          cachedElement.removeEventListener("mouseleave", handleTouchEnd);
         }
         clearTimeout(timerId);
         cachedElement = null;
         return;
       }

       cachedElement = element;
       cachedElement.addEventListener("wheel", handleWheel);
+      cachedElement.addEventListener("touchstart", handleTouchStart);
+      cachedElement.addEventListener("touchmove", handleTouchMove);
+      cachedElement.addEventListener("touchend", handleTouchEnd);
+      cachedElement.addEventListener("mousedown", handleTouchStart);
+      cachedElement.addEventListener("mousemove", handleTouchMove);
+      cachedElement.addEventListener("mouseup", handleTouchEnd);
+      cachedElement.addEventListener("mouseleave", handleTouchEnd);
     };
   }, [onFinishScroll]);

   return {
     ref,
   };
 };
```

ã“ã‚Œã§ã‚¿ãƒƒãƒæ“ä½œã§ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œäº†å¾Œã«å€¤ãŒé¸æŠã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ãŸã ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ“ä½œã‚’è‡ªå‰ã§å®Ÿè£…ã™ã‚‹ãŸã‚ã«`event.preventDefault`ã—ãŸã“ã¨ã«ã‚ˆã£ã¦clickã‚¤ãƒ™ãƒ³ãƒˆãŒæ‹¾ãˆãªããªã£ã¦ã‚¿ãƒƒãƒ—ã§é …ç›®ãŒé¸æŠã§ããªããªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã®å¯¾å¿œã«ã¤ã„ã¦ã¯å¾Œã»ã©å¯¾å¿œã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

![](/images/date-scroll-picker/demo-touch-scroll.gif)

### æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

ã“ã‚Œã§ã¨ã‚Šã‚ãˆãšã‚¿ãƒƒãƒæ“ä½œã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸãŒã€æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒãªã„ãŸã‚ã¡ã‚‡ã£ã¨é•å’Œæ„ŸãŒã‚ã‚Šã¾ã—ãŸã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚‚ç‰¹ã«æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ãªã•ãã†ã§ã€ç›®çš„ã®å€¤ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ãŒç›®çš„ãªã®ã§æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§å‹¢ã„ä½™ã£ã¦æ¬¡ã®é …ç›®ã®æ–¹ã«ç§»å‹•ã•ã‚Œã‚‹ã‹ãªã¨æ€ã£ã¦åˆã‚ã¯å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“ã§ã—ãŸãŒã€ã‚„ã¯ã‚Šè§¦ã£ã¦ã„ã¦ã‚ã£ãŸæ–¹ãŒè‰¯ã•ãã†ã ã£ãŸã®ã§ä½œã£ã¦ã¿ã¾ã—ãŸã€‚
å®Ÿè£…æ–¹æ³•ã¨ã—ã¦ã¯touchendæ™‚ã«touchstartã‹ã‚‰ã®è·é›¢ã¨æ™‚é–“ã‚’æ±‚ã‚ã¦æ¨å®šã®åˆé€Ÿã‚’æ±‚ã‚ã¦ã€ãã®é€Ÿåº¦ã‚’requestAnimationFrameã§æ¸›é€Ÿã•ã›ãªãŒã‚‰ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’èª¿æ•´ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚é€Ÿåº¦ãŒä¸€å®šã®é‡ã‚’ä¸‹å›ã£ãŸã‚‰requestAnimationFrameã‚’çµ‚äº†ã—ã¦`onFinishScroll`ã‚’å‘¼ã³ã¾ã™ã€‚å¾Œã¯ç´°ã‹ã„ã¨ã“ã‚ã§ã™ãŒæ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã«ã‚¿ãƒƒãƒ—ã—ãŸå ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒåœæ­¢ã§ãã‚‹ã‚ˆã†ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¦touchstartæ™‚ã«ãã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ã“ã®ç°¡æ˜“å®Ÿè£…ã ã¨æœ€åˆå¤§ããã‚¹ãƒ¯ã‚¤ãƒ—ã—ã¦ç§»å‹•ã‚’æ­¢ã‚ã¦ã‹ã‚‰æŒ‡ã‚’é›¢ã—ã¦ã‚‚ã€è¨ˆç®—ä¸Šæœ€åˆã¨æœ€å¾Œã®è·é›¢ã¨æ™‚é–“ã§å‡ã•ã‚Œã¦åˆé€ŸãŒè¨ˆç®—ã•ã‚Œã¦ã—ã¾ã†ãŸã‚ã€æ€ã£ã¦ã‚‚ã„ãªã„æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒå‡ºã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’èª¿æ•´ã™ã‚‹ã®ã¯ã‚ã¾ã‚Šã«ã‚‚è¨ˆç®—ã‚’é›£ã—ãã™ã‚‹ã®ã§å¯¾å¿œã¯ã—ã¦ã¾ã›ã‚“ãŒã€ç›´å‰ã®touchmoveã¨touchendã®é–“ã§ä¸€å®šã®æ™‚é–“ã‚’è¶…ãˆãŸã‚‰æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã›ãšã«ç›´ã¡ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’çµ‚äº†ã™ã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¾ã—ãŸã€‚ã“ã‚Œã¯PCã§ã‚¹ãƒãƒ›æ“ä½œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã‚’ã—ãŸéš›ã¯ä¸Šæ‰‹ãæ©Ÿèƒ½ã—ã¾ã—ãŸãŒå®Ÿéš›ã‚¹ãƒãƒ›ã§è©¦ã™ã¨æŒ‡ã‚’é›¢ã™ç¬é–“ã«touchmoveãŒç™ºç”Ÿã—ã¦ã—ã¾ã†ã“ã¨ãŒå¤šã‹ã£ãŸã®ã§ã‚ã¾ã‚ŠåŠ¹æœãŒãªã„ã‹ã‚‚ã—ã‚Œãªã„ã§ã™ã€‚ã€‚

```diff tsx:æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ã‚’å…¥ã‚Œã‚‹
+/**
+ * æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹
+ */
+const inertiaScroll = ({
+  element,
+  initialSpeed,
+  onFinishScroll,
+}: {
+  /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾è±¡ã®è¦ç´  */
+  element: HTMLElement;
+  /** åˆé€Ÿ */
+  initialSpeed: number;
+  /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒå®Œäº†ã—ãŸæ™‚ */
+  onFinishScroll: () => void;
+}): (() => void) => {
+  let speed = initialSpeed;
+  let frameId: number | undefined;
+  const frame = () => {
+    element.scrollTop += speed;
+    speed *= 0.85;
+    if (Math.abs(speed) < 0.5) {
+      onFinishScroll();
+      return;
+    }
+    frameId = requestAnimationFrame(frame);
+  };
+  frame();
+
+  const cancelInertiaScroll = () => {
+    if (frameId != null) {
+      cancelAnimationFrame(frameId);
+    }
+  };
+  return cancelInertiaScroll;
+};

 /**
  * ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’JSå´ã§åˆ¶å¾¡ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
  */
 export const useHandleScroll = ({
   onFinishScroll,
 }: {
   /** ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒçµ‚äº†ã—ãŸæ™‚ */
   onFinishScroll: () => void;
 }) => {
   const ref = useMemo(() => {
     let cachedElement: HTMLElement | null = null;
     // wheelã®å®šç¾©ã¯çœç•¥

     /** ã‚¿ãƒƒãƒé–‹å§‹åº§æ¨™ */
     let startPosY: number | null = null;
     /** ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½® */
     let startScrollTop: number | null = null;
+    /** ã‚¿ãƒƒãƒé–‹å§‹æ™‚åˆ» */
+    let touchStartTime: number | null = null;
+    /** ã‚¿ãƒƒãƒæ“ä½œã®æœ€çµ‚æ™‚åˆ» */
+    let touchLastMoveTime: number | null = null;
+    /** æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ */
+    let cancelInertiaScroll: (() => void) | undefined;
     const handleTouchStart = (event: TouchEvent | MouseEvent) => {
       event.preventDefault();
+      if (cancelInertiaScroll != null) {
+        cancelInertiaScroll();
+        cancelInertiaScroll = undefined;
+      }
       startPosY =
         "touches" in event ? event.touches[0]?.clientY ?? null : event.clientY;
       startScrollTop = cachedElement?.scrollTop ?? null;
+      touchStartTime = performance.now();
     };
     const handleTouchMove = (event: TouchEvent | MouseEvent) => {
       if (
         startPosY == null ||
         startScrollTop == null ||
         cachedElement == null
       ) {
         return;
       }
       const posY =
         "touches" in event ? event.touches[0]?.clientY : event.clientY;
       if (posY == null) {
         return;
       }
       const diff = startPosY - posY;
       cachedElement.scrollTop = startScrollTop + diff;
+      touchLastMoveTime = performance.now();
     };
     const handleTouchEnd = (event: TouchEvent | MouseEvent) => {
+      const reset = () => {
+        startPosY = null;
+        startScrollTop = null;
+        touchStartTime = null;
+        touchLastMoveTime = null;
+        cancelInertiaScroll = undefined;
+      };
       event.preventDefault();
-
-      startPosY = null;
-      startScrollTop = null;
-      onFinishScroll();

+      const endTime = performance.now();
+      if (
+        cachedElement == null ||
+        startPosY == null ||
+        startScrollTop == null ||
+        touchStartTime == null ||
+        touchLastMoveTime == null ||
+        // touchmoveã‹ã‚‰ã®çµŒéæ™‚é–“ãŒ50msä»¥ä¸Šã ã£ãŸå ´åˆã‚‚æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯è¡Œã‚ãšã€ãã®å ´ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’çµ‚äº†ã™ã‚‹
+        endTime - touchLastMoveTime > 50
+      ) {
+        reset();
+        onFinishScroll();
+        return;
+      }
+
+      const elapsedTime = endTime - touchStartTime;
+      const distance = cachedElement.scrollTop - startScrollTop;
+      reset();
+      cancelInertiaScroll = inertiaScroll({
+        element: cachedElement,
+        initialSpeed: (20 * distance) / elapsedTime,
+        onFinishScroll,
+      });
     };
     return (element: HTMLElement | null) => {
       // å·®åˆ†ãŒãªã„ãŸã‚çœç•¥
     };
   }, [onFinishScroll]);

   return {
     ref,
   };
 };
```

ã“ã‚Œã§ä»¥ä¸‹ã®ã‚ˆã†ã«æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã®éƒ¨åˆ†ã‚’èª¿æ•´ã™ã‚‹ã“ã¨ã§åˆé€Ÿã‚„æ¸›è¡°é‡ã‚’èª¿æ•´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

![](/images/date-scroll-picker/demo-inertia-scroll.gif)

### é …ç›®ã‚’ã‚¿ãƒƒãƒ—ã§é¸æŠã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

è‡ªå‰ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ã™ã‚‹ãŸã‚ã«`event.preventDefault`ã‚’ã—ãŸã“ã¨ã§ã‚¿ãƒƒãƒ—ã§ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šãŒã§ããªããªã£ã¦ã—ã¾ã£ãŸãŸã‚ã€ã‚¿ãƒƒãƒ—åˆ¤å®šã‚‚è‡ªä½œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å˜ç´”ã«touchendã§ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã§ã‚‚ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã•ã‚Œã¦ã—ã¾ã†ãŸã‚ã€ã¯touchstartã‹ã‚‰touchendã®é–“ã§åº§æ¨™ã®ãšã‚ŒãŒå°ã•ã‘ã‚Œã°ã‚¯ãƒªãƒƒã‚¯ã¨ã—ã¦åˆ¤å®šã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä»Šå›ã¯mouseæ“ä½œã‚‚åˆã‚ã›ã¦åå¿œã§ãã‚‹ã‚ˆã†ã«pointerã‚¤ãƒ™ãƒ³ãƒˆã§å®Ÿè£…ã—ã¾ã—ãŸã€‚

```ts:ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã¯ç„¡åŠ¹ã«ã—ã¦ã€ç´”ç²‹ãªã‚¯ãƒªãƒƒã‚¯æ“ä½œã®ã¿ã‚’æ¤œçŸ¥ã™ã‚‹hooks
import { useEffect, useState, useRef } from "react";

export type UseJustClickArgs = {
  /**
   * ãƒ‰ãƒ©ãƒƒã‚°ã¨åˆ¤å®šã•ã‚Œã‚‹å¤‰åŒ–é‡(px)
   * @default 5
   */
  dragThreshold?: number;
  /** æ©Ÿèƒ½ã‚’OFFã«ã™ã‚‹ã‹ */
  disabled?: boolean;
  /**
   * ã‚¯ãƒªãƒƒã‚¯æ™‚
   */
  onJustClick: () => void;
};

export type UseJustClickReturn = {
  /** ç›£è¦–å¯¾è±¡ã®DOMã®ref */
  ref: (element: HTMLElement | null) => void;
};

/**
 * ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã¯ç„¡åŠ¹ã«ã—ã¦ã€ç´”ç²‹ãªã‚¯ãƒªãƒƒã‚¯æ“ä½œã®ã¿ã‚’æ¤œçŸ¥ã™ã‚‹hooks
 */
export const useJustClick = ({
  dragThreshold = 5,
  disabled,
  onJustClick,
}: UseJustClickArgs): UseJustClickReturn => {
  const [element, setElement] = useState<HTMLElement | null>(null);

  // depsã®å¯¾è±¡ã«å«ã¾ã‚Œãªã„ã‚ˆã†ã«refã§ä¿æŒã™ã‚‹
  const onJustClickRef = useRef(onJustClick);
  onJustClickRef.current = onJustClick;

  useEffect(() => {
    if (element == null || disabled) {
      return;
    }

    /** ã‚¯ãƒªãƒƒã‚¯é–‹å§‹åº§æ¨™ */
    let startPos: { x: number; y: number } | null = null;
    const handlePointerDown = (event: PointerEvent) => {
      // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨mousedownã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã—ãªããªã‚‹ã®ã§preventDefaultã¯ã—ãªã„
      // event.preventDefault();
      startPos = {
        x: event.clientX,
        y: event.clientY,
      };
    };
    const handlePointerUp = (event: PointerEvent) => {
      // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨mouseupã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã—ãªããªã‚‹ã®ã§preventDefaultã¯ã—ãªã„
      // event.preventDefault();
      if (startPos == null) {
        return;
      }

      // ãƒ‰ãƒ©ãƒƒã‚°ã®è·é›¢ãŒdragThresholdã‚’è¶…ãˆãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šã«ã—ã¦ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ãªã„
      const dx = startPos.x - event.clientX;
      const dy = startPos.y - event.clientY;
      startPos = null;
      if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
        return;
      }

      onJustClickRef.current();
    };
    const handlePointerLeave = () => {
      // ãƒã‚¤ãƒ³ã‚¿ãŒå¤–ã‚Œã¦ã—ã¾ã£ãŸæ™‚ã¯ã‚¯ãƒªãƒƒã‚¯é–‹å§‹åº§æ¨™ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
      startPos = null;
    };

    element.addEventListener("pointerdown", handlePointerDown);
    element.addEventListener("pointerup", handlePointerUp);
    element.addEventListener("pointerleave", handlePointerLeave);

    return () => {
      element.removeEventListener("pointerdown", handlePointerDown);
      element.removeEventListener("pointerup", handlePointerUp);
      element.removeEventListener("pointerleave", handlePointerLeave);
    };
  }, [element, disabled, dragThreshold]);

  return {
    ref: setElement,
  };
};
```

ä½™è«‡ã§ã™ãŒã“ã®å®Ÿè£…ã¯ä»¥ä¸‹ã®è¨˜äº‹ã®é€†ã®å®Ÿè£…ã«ãªã£ã¦ã„ã¾ã™ã€‚

https://zenn.dev/numa_san/articles/34ef632e1cf373

ã“ã®hooksã‚’å„é …ç›®ã”ã¨ã«è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«åˆ‡ã‚Šå‡ºã—ã¾ã™ã€‚

```tsx:å„é …ç›®ã”ã¨ã«è¡¨ç¤ºã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«useJustClickã‚’è¨­å®šã™ã‚‹
import { ListItemText, MenuItem } from "@mui/material";
import type { FC, ReactNode } from "react";

import { SCROLL_ITEM_HEIGHT } from "./constants/ScrollItemHeight";
import { useJustClick } from "./hooks/useJustClick";

export type ScrollPickerItemProps = {
  /** é¸æŠã•ã‚Œã¦ã„ã‚‹ã‹ */
  selected?: boolean;
  /** éæ´»æ€§ã‹ */
  disabled?: boolean;
  /** å­è¦ç´  */
  children: ReactNode;
  /**
   * ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã¯ç„¡åŠ¹ã«ã—ã¦ç´”ç²‹ãªã‚¯ãƒªãƒƒã‚¯æ“ä½œã®ã¿ã‚’æ¤œçŸ¥ã—ãŸæ™‚
   */
  onJustClick: () => void;
};

export const ScrollPickerItem: FC<ScrollPickerItemProps> = ({
  selected,
  disabled,
  children,
  onJustClick,
}) => {
  const { ref } = useJustClick({
    disabled,
    onJustClick: () => {
      // ScrollPickerã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®åˆ¤å®šå¾Œã«clickã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã•ã›ãŸã„ã®ã§ãƒ¯ãƒ³ã‚µã‚¤ã‚¯ãƒ«é…ã‚‰ã›ã‚‹
      setTimeout(() => {
        onJustClick();
      });
    },
  });

  return (
    <MenuItem
      ref={ref}
      style={{
        height: SCROLL_ITEM_HEIGHT,
        minHeight: "auto",
        textAlign: "center",
      }}
      selected={selected}
      disabled={disabled}
    >
      <ListItemText
        sx={{
          "& > .MuiListItemText-primary": {
            fontWeight: selected ? "bold" : undefined,
          },
        }}
        primary={children}
      />
    </MenuItem>
  );
};
```

ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«å·®ã—æ›¿ãˆã‚‹ã“ã¨ã§å®Œæˆã§ã™ã€‚

```diff tsx:ScrollPickerItemã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½¿ã†ã‚ˆã†ã«å·®ã—æ›¿ãˆã‚‹
 // çœç•¥
+import { ScrollPickerItem } from "./ScrollPickerItem";

 export const ScrollPicker = function <V>({
   value,
   items,
   height = 5 * SCROLL_ITEM_HEIGHT,
   onChangeValue,
 }: ScrollPickerProps<V>) {
   // ä¸€éƒ¨çœç•¥

   return (
     <Box
       sx={{
         position: "relative",
         height,
         "&::before": createPseudoShadowStyle("top"),
         "&::after": createPseudoShadowStyle("bottom"),
       }}
     >
       <MenuList
         ref={handleRef}
         sx={{
           height: "100%",
           overflowY: "scroll",
           "&::-webkit-scrollbar": {
             display: "none",
           },
         }}
         disablePadding
       >
         <MenuItem
           key={`pad-top`}
           sx={{
             height: paddingHeight,
             minHeight: "auto",
           }}
           disabled
         />
         {items.map((item) => (
-          <MenuItem
-            key={String(item.value)}
-            style={{
-              height: SCROLL_ITEM_HEIGHT,
-              minHeight: "auto",
-              textAlign: "center",
-            }}
-            selected={item.value === value}
-            disabled={item.disabled}
-            onClick={() => {
-              onChangeValue(item.value)
-            }}
-          >
-            <ListItemText
-              sx={{
-                "& > .MuiListItemText-primary": {
-                  fontWeight: item.value === value ? "bold" : undefined,
-                },
-              }}
-              primary={item.label}
-            />
-          </MenuItem>
+          <ScrollPickerItem
+            key={String(item.value)}
+            selected={item.value === value}
+            disabled={item.disabled}
+            onJustClick={() => {
+              onChangeValue(item.value);
+            }}
+          >
+            {item.label}
+          </ScrollPickerItem>
         ))}
         <MenuItem
           key={`pad-bottom`}
           sx={{
             height: paddingHeight,
             minHeight: "auto",
           }}
           disabled
         />
       </MenuList>
     </Box>
   );
 };
```

ã“ã‚Œã§ã‚¿ãƒƒãƒ—ã§é¸æŠã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šæ™‚ã«ã¯ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã«ãªã‚‰ãªãã—ãŸã®ã§touchstartå¾Œã«å°‘ã—æŒ‡ã‚’å‹•ã‹ã—ã¦ã‹ã‚‰touchendã—ãŸå ´åˆã¯é¸æŠã•ã‚Œãšã€é¸æŠã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚’ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

![](/images/date-scroll-picker/demo-tap-select.gif)

## DateScrollPickerã®ä½œæˆ

å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ä½œã£ãŸ`ScrollPicker`ã‚’ä½¿ã£ã¦å¹´æœˆæ—¥ãã‚Œãã‚Œã‚’è¨­å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚æ—¥ä»˜ã®é¸æŠã«ãŠã„ã¦ã€ä»¥ä¸‹ã«ã¤ã„ã¦ã‚±ã‚¢ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

- æœ€å°æ—¥ä»˜ã¨æœ€å¤§æ—¥ä»˜ã®ç¯„å›²ã‚’è¶…ãˆã¦ã‚’é¸æŠã—ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«èª¿æ•´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
- 31æ—¥ã®æœˆã¨29æ—¥ã®æœˆãªã©æ—¥ã«ã¡ãŒé•ã†å ´åˆã«å­˜åœ¨ã—ãªã„æ—¥ã«ã¡ãŒé¸æŠã•ã‚ŒãŸã¾ã¾ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼ˆãã®æœˆã®æœ€å¤§æ—¥ã«ã¡ã«èª¿æ•´ã™ã‚‹ï¼‰

```tsx:DateScrollPicker.tsx
import { FC, useMemo, useCallback } from "react";
import { Stack, Typography } from "@mui/material";
import { ScrollPicker } from "./ScrollPicker";
import { range } from "lodash-es";
import { addYears, clamp as clampDate } from "date-fns";

const CURRENT_DATE = new Date();
const DEFAULT_MIN_DATE = addYears(CURRENT_DATE, -100);
const DEFAULT_MAX_DATE = addYears(CURRENT_DATE, 100);

export type DateScrollPickerProps = {
  /** æ—¥ä»˜ */
  value: Date;
  /** æœ€å°æ—¥ä»˜ */
  minDate?: Date;
  /** æœ€å¤§æ—¥ä»˜ */
  maxDate?: Date;
  /**
   * æ—¥ä»˜ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚
   * @param newValue - æ–°ã—ã„æ—¥ä»˜
   */
  onChangeValue: (newValue: Date) => void;
};

export const DateScrollPicker: FC<DateScrollPickerProps> = ({
  value,
  minDate = DEFAULT_MIN_DATE,
  maxDate = DEFAULT_MAX_DATE,
  onChangeValue,
}) => {
  const { year, month, day } = useMemo(() => {
    return {
      year: value.getFullYear(),
      month: value.getMonth() + 1,
      day: value.getDate(),
    };
  }, [value]);
  const maxDayOfCurrentMonth = useMemo(() => {
    return new Date(year, month, 0).getDate();
  }, [month, year]);

  const yearItems = useMemo(() => {
    return range(minDate.getFullYear(), maxDate.getFullYear() + 1).map(
      (year) => ({
        value: year,
        label: `${year}`,
      })
    );
  }, [minDate, maxDate]);

  const monthItems = useMemo(() => {
    return range(1, 13).map((month) => {
      const yearMonthFirst = new Date(year, month - 1, 1, 0, 0, 0);
      const yearMonthLast = new Date(year, month, 0, 23, 59, 59);
      return {
        value: month,
        label: `${month}`,
        disabled: yearMonthLast < minDate || yearMonthFirst > maxDate,
      };
    });
  }, [maxDate, minDate, year]);

  const dayItems = useMemo(() => {
    return range(1, maxDayOfCurrentMonth + 1).map((day) => {
      const dateFirst = new Date(year, month - 1, day, 0, 0, 0);
      const dateLast = new Date(year, month - 1, day, 23, 59, 59);
      return {
        value: day,
        label: `${day}`,
        disabled: dateLast < minDate || dateFirst > maxDate,
      };
    });
  }, [maxDate, maxDayOfCurrentMonth, minDate, month, year]);

  const handleChangeValue = useCallback(
    (newDate: Date) => {
      onChangeValue(
        clampDate(newDate, {
          start: minDate,
          end: maxDate,
        })
      );
    },
    [maxDate, minDate, onChangeValue]
  );

  return (
    <Stack direction="row" spacing={1} alignItems="center">
      <ScrollPicker
        value={year}
        items={yearItems}
        onChangeValue={(newYear) => {
          /** æ¬¡ã®å¹´æœˆã®æœ€å¤§æ—¥æ•° */
          const maxDayOfNextMonthYear = new Date(newYear, month, 0).getDate();
          handleChangeValue(
            new Date(
              newYear,
              month - 1,
              // æœ€å¤§æ—¥æ•°ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
              Math.min(day, maxDayOfNextMonthYear)
            )
          );
        }}
      />
      <Typography>å¹´</Typography>
      <ScrollPicker
        value={month}
        items={monthItems}
        onChangeValue={(newMonth) => {
          /** æ¬¡ã®æœˆã®æœ€å¤§æ—¥æ•° */
          const maxDayOfNextMonth = new Date(year, newMonth, 0).getDate();
          handleChangeValue(
            new Date(
              year,
              newMonth - 1,
              // æœ€å¤§æ—¥æ•°ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
              Math.min(day, maxDayOfNextMonth)
            )
          );
        }}
      />
      <Typography>æœˆ</Typography>
      <ScrollPicker
        value={day}
        items={dayItems}
        onChangeValue={(newDay) => {
          handleChangeValue(new Date(year, month - 1, newDay));
        }}
      />
      <Typography>æ—¥</Typography>
    </Stack>
  );
};
```

å‹•ä½œã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚Šã¾ã™ã€‚

![](/images/date-scroll-picker/demo-date-scroll-picker.gif)

## InputDateByScrollPickerã®ä½œæˆ

æœ€å¾Œã«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¾ãŸã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§ `DateScrollPicker` ã‚’è¡¨ç¤ºã—ã¦ã€æ—¥ä»˜ã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œã‚Šã¾ã™ã€‚ä»Šã¾ã§ScrollPickerã§ã¯åˆæœŸå€¤ãŒãªã„ã¨æœ€åˆã«è¡¨ç¤ºã™ã‚‹ã‚‚ã®ãŒåˆ†ã‹ã‚‰ãªã„ãŸã‚requiredã«ã—ã¦ã„ã¾ã—ãŸãŒã€ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã ã¨nullableã«ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒãƒ„ã‚¢ã‚¤ã‚³ãƒ³ã‚’ç”¨æ„ã—ã¦é¸æŠã—ãŸæ—¥ä»˜ã‚’æ¶ˆã™ã“ã¨ã‚‚ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

```tsx:InputDateByScrollPicker.tsx
import { FC, useState } from "react";
import { formatDate } from "date-fns";
import {
  TextField,
  InputAdornment,
  IconButton,
  Button,
  Dialog,
  DialogContent,
  DialogActions,
  Popover,
} from "@mui/material";
import EventIcon from "@mui/icons-material/Event";
import CloseIcon from "@mui/icons-material/Close";

import { DateScrollPicker, DateScrollPickerProps } from "./DateScrollPicker";

const InputDateContent: FC<
  {
    initialDate: Date;
    onCancel: () => void;
    onSubmit: (newDate: Date) => void;
  } & Pick<DateScrollPickerProps, "minDate" | "maxDate">
> = ({ initialDate, onCancel, onSubmit, ...restProps }) => {
  const [currentDate, setCurrentDate] = useState(initialDate);

  return (
    <>
      <DialogContent dividers>
        <DateScrollPicker
          value={currentDate}
          onChangeValue={setCurrentDate}
          {...restProps}
        />
      </DialogContent>
      <DialogActions>
        <Button onClick={onCancel}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
        <Button
          variant="contained"
          onClick={() => {
            onSubmit(currentDate);
          }}
        >
          æ±ºå®š
        </Button>
      </DialogActions>
    </>
  );
};

const DEFAULT_INITIAL_PICKER_DATE = new Date();

export type InputDateByScrollPickerProps = {
  /** æ—¥ä»˜ */
  value: Date | null;
  /**
   * Pickerã‚’è¡¨ç¤ºã™ã‚‹éš›ã«ä½¿ã†UI
   * - "dialog": ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
   * - "popover": ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—
   */
  pickerUi: "dialog" | "popover";
  /** valueãŒnullã®æ™‚ã«Pickerã«åˆæœŸè¡¨ç¤ºã™ã‚‹æ—¥ä»˜ */
  initialPickerDate?: Date;
  /**
   * æ—¥ä»˜ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚
   * @param newValue - æ–°ã—ã„æ—¥ä»˜
   */
  onChangeValue: (newValue: Date | null) => void;
} & Pick<DateScrollPickerProps, "minDate" | "maxDate">;

export const InputDateByScrollPicker: FC<InputDateByScrollPickerProps> = ({
  value,
  pickerUi,
  initialPickerDate = DEFAULT_INITIAL_PICKER_DATE,
  onChangeValue,
  ...restProps
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [elAnchor, setElAnchor] = useState<HTMLElement | null>(null);

  return (
    <>
      <TextField
        value={value ? formatDate(value, "yyyy/MM/dd") : ""}
        variant="outlined"
        size="small"
        placeholder="é¸æŠã—ã¦ãã ã•ã„"
        fullWidth
        slotProps={{
          input: {
            readOnly: true,
            endAdornment: (
              <InputAdornment position="end">
                {value != null && (
                  <IconButton
                    onClick={(event) => {
                      event.stopPropagation();
                      onChangeValue(null);
                    }}
                  >
                    <CloseIcon />
                  </IconButton>
                )}
                <EventIcon />
              </InputAdornment>
            ),
            sx: {
              cursor: "pointer",
              "& > .MuiInputBase-input": {
                cursor: "pointer",
              },
            },
          },
        }}
        onClick={(event) => {
          setIsOpen(true);
          setElAnchor(event.currentTarget);
        }}
      />
      {pickerUi === "dialog" && (
        <Dialog
          open={isOpen}
          onClose={() => {
            setIsOpen(false);
          }}
        >
          <InputDateContent
            {...restProps}
            initialDate={value ?? initialPickerDate}
            onCancel={() => {
              setIsOpen(false);
            }}
            onSubmit={(newDate) => {
              onChangeValue(newDate);
              setIsOpen(false);
            }}
          />
        </Dialog>
      )}
      {pickerUi === "popover" && (
        <Popover
          open={elAnchor != null && isOpen}
          anchorEl={elAnchor}
          anchorOrigin={{
            vertical: "bottom",
            horizontal: "center",
          }}
          transformOrigin={{
            vertical: "top",
            horizontal: "center",
          }}
          onClose={() => {
            setIsOpen(false);
            setElAnchor(null);
          }}
        >
          <InputDateContent
            {...restProps}
            initialDate={value ?? initialPickerDate}
            onCancel={() => {
              setIsOpen(false);
              setElAnchor(null);
            }}
            onSubmit={(newDate) => {
              onChangeValue(newDate);
              setIsOpen(false);
              setElAnchor(null);
            }}
          />
        </Popover>
      )}
    </>
  );
};
```

å‹•ä½œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã‚¹ãƒãƒ›ã ã¨ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®æ–¹ãŒè‰¯ã„ã‹ãªã¨æ€ã„ã¤ã¤ã€PCã ã¨ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®æ–¹ãŒè‰¯ã•ãã†ã§ã‚¹ãƒãƒ›ã‚‚ã“ã£ã¡ã§ã‚‚å•é¡Œãªã•ãã†ãªæ°—ãŒã™ã‚‹ã®ã§ã€å®Ÿéš›ã«ä½¿ç”¨ã™ã‚‹éš›ã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§çµ±ä¸€ã—ã¦ã‚‚è‰¯ã•ãã†ãªå°è±¡ã§ã—ãŸã€‚

![](/images/date-scroll-picker/demo-input-date-by-scroll-picker-from-dialog.gif)
![](/images/date-scroll-picker/demo-input-date-by-scroll-picker-from-popup.gif)

## çµ‚ã‚ã‚Šã«

ä»¥ä¸ŠãŒãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã§æ—¥ä»˜ã‚’é¸æŠã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹å†…å®¹ã§ã—ãŸã€‚ScrollPickerãŒãƒã‚¦ã‚¹ã¨ã‚¿ãƒƒãƒä¸¡æ–¹å¯¾å¿œã—ã€ã‹ã¤æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚‚å®Ÿè£…ã—ãŸã“ã¨ã«ã‚ˆã£ã¦çµæ§‹é•·ããªã£ã¦ã—ã¾ã„ã¾ã—ãŸãŒã€æ“ä½œæ„Ÿã¯ã‹ãªã‚Šè‰¯ã•ãã†ã§ã—ãŸã€‚ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«UIã‚’å®Ÿè£…ã—ãŸã„æ–¹ã®å‚è€ƒã«ãªã‚ŒãŸã‚‰å¹¸ã„ã§ã™ã€‚
